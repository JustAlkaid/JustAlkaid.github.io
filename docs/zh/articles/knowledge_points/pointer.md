# 12 问带你速通指针

## 什么是指针？
指针是存储**内存地址**的变量。指针变量的**值**叫做**指针指向的内存地址**。如果指针指向的内存地址属于某个变量，就说指针**指向这个变量**。
```C
int a = 114514;
int* p = &a;            //用取地址运算符 & 得到变量 a 的内存地址，随后把这个地址赋给 int* 型的指针变量 p
printf("%#010x", p);    //以十六进制输出 p 的值，用 0x 开头，包括 0x 在内至少 10 个字符
```
运行结果：
```C
> 0x00f3fe3c
```
（每次执行可能都会不同）

## 怎么定义指针？
在任何一个正常的数据类型后面加上`*`字符，就可以得到一个该数据类型衍生出的指针。
```C
int* p;                             //创建了一个 int* 型的指针
double* a;                          //创建了一个 double* 型的指针

struct student{                     //如果你还不知道什么是结构体，跳过这部分
    int age;
    char name[100];
};
typedef struct student student;
student* q;                         //创建了一个 struct student* 型的指针

int *a;                             //空格的位置无所谓。有人认为这种写法强调 *a 是一个 int 型变量，而正常写法强调 a 是一个 int* 型变量
int *a, *b;                         //创建了两个 int* 型指针 a 和 b
int* a, b;                          //创建了一个 int* 型指针 a 和一个 int 型变量 b，因此，声明指针时，每个指针前面都需要出现 * 字符
```

## 指针占据多大的内存空间？
依机器而定。市面上的电脑大多采用 64 位系统，此时指针变量占据 8 个字节的内存。如果你的电脑使用了 32 位系统或者在 64 位系统上安装了 32 位编译器，指针变量会占据 4 个字节的内存。  
*不难看出，4 个字节恰好是 32 位， 8 个字节恰好是 64 位。*

指针变量占据的内存与其类型无关。

```C
int *ptr = NULL;
printf("%zu", sizeof(ptr)); //使用 sizeof 运算符获取指针占用的内存空间的大小，以字节数表示
```

运行结果：
```C
> 4 （32 位系统/编译器）
> 8 （64 位系统和编译器）
```

*碎碎念：32 位系统下，一个指针占据 4 个字节，有 2^32 = 4,294,967,296 个可能的值，CPU 利用这样一个指针变量，最多能访问 4,294,967,296 个不同的字节。*  
*1KB = 1024byte， 1MB = 1024KB， 1GB = 1024MB，计算可得 32 位 CPU 可用的内存最多不超过 4GB，这远远不能满足不断发展的软件对内存的需求。*  
*随着芯片制造工艺的发展，超过 4GB 的大容量内存在市场上越来越常见，越来越廉价，32 位系统也就此退出了历史舞台。*

## 指针的类型表示什么？
指针变量的类型决定了它所指向的内存地址上存放的数据类型，换句话说，指针变量的类型告诉程序如何解释该内存地址上的数据。
```C
int* p = (int*)malloc(sizeof(int)); //分配一块大小为 int 变量大小的内存，赋值给 int* 型指针 p
//假定这部分代码运行在一个 int 变量为 4 个字节的机器上
//p 的类型是 int*，这告诉程序，要把 p 指向的字节和其后的 3 个字节存储的内容视为一个 int 型变量
```
粗略的说，如果你想知道一个指针的类型，那就从它的定义中把它的名字去掉，**保留所有其他的符号**。  
*（叹气）是的，这里有很多运算符优先级和结合性的问题。*
```C
int* p;                                                          //类型：int*
double** q;                                                      //类型：double**
char (*a)[20]                                                    //类型：char(*)[20]
int (*b)(int, int)                                               //类型：int (*)(int, int)
float (*c)(long long, short, void (*)(const void*, const void*)) //类型：float (*)(long long, short, void (*)(const void*, const void*))
```
*你得到了他们的类型，但这有什么用呢？这东西根本复杂到人不能理解。问问 AI 怎么样？*  
*C++ 允许程序员在变量初始化时，直接用 `auto` 关键字替代这些冗长的类型。也许是时候转投 C++ 了？*

## 怎么使用指针？
对指针使用解引用运算符`*`，可以得到指针**指向的变量**的值。
```C
int a = 23333;
int* p = &a;        //指针存储了变量 a 的地址，或者说指针指向了变量 a
printf("%d", *p);   //输出指针指向的变量的值，即输出 a 的值。
```
运行结果：
```C
> 23333
```
对指针执行加法和减法，实质是指针指向的位置的移动，这被称为**指针算术**。  
指针算术受到指针变量类型的影响。每次对指针 +1，相当于把指针指向的位置向后移动一个“指针指向的数据类型”的大小。
```C
int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

int* p = a;                 //p 指向 a 的首地址，或者说 p 指向 a[0]
printf("%d\n", *p);         

printf("%d\n", *(p + 1));   /* p 是 int* 型指针，p + 1 表示 p 指向的位置向后移动一个 int 变量的大小，
                             * 因此 (p + 1) 指向 a[1]，注意这里的运算符优先级。
                             */

p = p + 2;                  //把 p 向后移动 2 个 int 变量的大小，指向 a[2]
printf("%d\n", *p);  

--p;                        //把 p 向前移动 1 个 int 变量的大小，指向 a[1]
printf("%d\n", *p); 

printf("%d\n", *p++);       /* 后置 ++ 的优先级高于解引用 *，因此 *p++ 被理解为*(p++)，
                             * 于是 * 运算符使用 p 自增前的值，为 printf 传入 1，
                             * 之后执行自增，p 向后移动 1 个 int 变量的大小，p指向 a[2]。
                             * 总之，如果你不知道运算符是怎么结合的，要么用括号，要么别这么写。
                             */
printf("%d\n", *p); 
```
运行结果：
```C
> 0
> 1
> 2
> 1
> 1
> 2
```
指向同一块内存的，相同类型的指针可以进行减法运算，结果是两个指针之间相差的元素个数（以它们指向的类型为单位）。这也是一种指针算术。
```C
int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int* p = a;
int* q = a;
q += 6;
printf("%d", q - p);
```
运行结果：
```C
> 6
```
这可以用来计算数组中两个元素之间的距离。

将没有指向同一块内存的指针相减是未定义行为，其结果是不可预测的，**不应该这样做**。  
将不同类型的指针做减法是未定义行为。在某些编译器上会触发警告，另一些编译器会会直接触发一个编译错误。

## 多重指针是什么？
**指向指针的指针**被称为多重指针。多重指针的数据类型告诉程序，要把本指针指向的内存空间存储的数据也视为一个内存地址。  
你可以根据需要创建二重，三重或者更多重指针。
```C
char c = '!';
char* p1 = &c;
char** p2 = &p1;            //创建一个 char** 类型的指针 p2，char** 可以视为是 char* 衍生出的数据类型
printf("%c\n", *p1);        //p1 指向 c, *p1 是 c，输出 c 的值（字符）
printf("%#010x\n", *p2);    //p2 指向 p1, *p2 是 p1，输出 p1 的值（内存地址）
printf("%c\n", **p2);       //**p2 是*(*p2)，也就是 *p1，最后输出 c 的值（字符）
```
运行结果：
```C
> !
> 0x005cf86b
> !
```
输出的地址每次执行可能都会不同。

## 指针和数组的关系
数组和指针是两种**不同**的数据类型。但由于 C 语言的某些设计，数组名往往也可以当做指针使用。
1. 在绝大多数需要地址的表达式中，数组名被隐式转换为指向其首元素的指针：
    ```C
    char a[10] = "bilibili";
    char* p = a;                //a 被转换成了 &a[0]，因此这一行实际上是char* p = &a[0]
    ```
    多维数组的情况差不多，只是会产生数组指针：
    ```C
    char a[2][10] = {"Hello", "World"};
    char (*p)[10] = a;          //实际上是char (*p)[10] = &a[0]
    printf("%s", p[1]);
    ```
    运行结果：
    ```C
    > World
    ```

2. 在函数形参列表里出现的数组会被转换成指向其元素具有的类型的指针。这意味着下面三个函数原型（对于编译器）是相同的：
    ```C
    void printArray(int* array);        //指针
    void printArray(int array[]);       //写成了数组但是略去了长度，被编译器视为指针
    void printArray(int array[16384]);  //写成了数组而且规定了长度，但是编译器会忽略长度，然后视为指针
    ```
    多维数组是“元素是数组的数组”，因此被写在函数的形参列表里时，会被认为是数组指针。因此以下三个函数原型也是相同的：
    ```C
    void print2DArray(int (*arr)[4], int rows); //数组指针
    void print2DArray(int arr[][4], int rows);  //被编译器认为是数组指针
    void print2DArray(int arr[2][4], int rows); //一样被编译器认为是数组指针
    ```

3. 在函数实参列表里出现的数组名也会被隐式转换为指向其首元素的指针：
    ```C
    void printArray(int array[]);
    //...
    int a[3] = {0, 1, 2};
    printArray(a);
    printArray(&a[0])       //和上一行相同
    ```
    多维数组的情况也差不多，会被隐式转换为数组指针：
    ```C
    void print2DArray(int arr[][4], int rows);
    //...
    int a[2][2]= {{0, 1}, {2, 3}};
    print2DArray(a, 2);
    print2Darray(&a[0], 2); //和上一行相同
    ```

## 顶层 const？底层 const？？
*我的记忆方法：`const`关键字**后面最近的**是常量。*

这是顶层`const`，它表示指针本身的值（指针保存的内存地址）不能被修改:
```C
int a = 10;
int b = 20;
int* const p = &a;  //顶层 const
*p = 64;            //对 *p 修改与顶层 const 无关
p = &b;             //修改了 p 的值（p 保存的内存地址），触发一个编译错误
```
*`const`后面最近的是`p`，那么`p`就是常量。*

这是底层`const`，它表示指针指向一个常量。
```C
int a = 10;
const int b = 20;
const int* p = &b;  //底层 const
p = &a;             //修改 p 的值（p 保存的内存地址）与底层 const 无关
a = 8192;           //没办法通过 *p 修改 a 的值，但 a 本身不是常量，可以直接被修改——所以，如果底层 const 指针指向的不是常量，那没有任何意义
*p = 64;            //修改了 *p 的值，触发一个编译错误
```
*`const`后面最近的是`int*`，那么`int*`就是常量。*

两种`const`也可以一起使用。
```C
const int a = 64;
const int b = 256;
const int* const p = &a;
*p = 1;             //这也不行
p = &b;             //那也不行
```
*这种情况简单多了，不是吗？*


## 数组指针？还是指针数组？
数组指针是**指针**，指针数组是**数组**。  
更详细地说，数组指针是**指向数组的指针**，指针数组是**元素是指针的数组**。  
*（叹气）是的，这里也有很多运算符优先级和结合性的问题。*
```C
int (*a)[20];   //创建了一个类型为 int(*)[20] 的数组指针
int* b[20];     //创建了一个指针数组 b，它的每一个元素都是一个 int* 指针
```
与其他指针一样，数组指针的类型告诉程序该把它指向的内存地址解释为一个数组。
```C
int (*a)[20] = (int*[20])calloc(20, sizeof(int));  //*a 是一个有 20 个 int 元素的数组
printf("%d", (*a)[5]);                             //访问这个数组的第 5 个元素
```
运行结果：
```C
> 0
```
指针数组就**只是**元素是指针的数组。仅此而已。
```C
int* p[10];                                         //创建一个有 10 个 int* 类型元素的数组 p
for (int i = 0; i < 10; ++i) {
    p[i] = (int*)calloc(10, sizeof(int));           //为 p 的每一个元素——int* 指针分配一块内存
}
```
## 按值传递？按指针传递？
函数形参列表里出现的是普通的变量，称为**按值传递**。此时，形参是实参的值拷贝，函数内部对形参的修改不会影响实参。
```C
void modifyValue(int x) {
    x += 114514;
    x *= 1919;
}
int main() {
    int a = 1;
    modifyValue(a);     //modfiyValue() 函数不会对 main() 函数的 a 产生任何影响
    printf("%d", a);
    return 0;
}
```
运行结果：
```C
> 1
```

函数形参列表里出现的是指针，称为**按指针传递**。
```C
void modifyValue(int* x) {
    *x += 114514;
    *x *= 1919;
}
int main() {
    int a = 1;
    modifyValue(&a);     //modfiyValue() 函数会修改 main() 函数的 a
    printf("%d", a);
    return 0;
}
```
运行结果：
```C
> 219752366
```
*仔细想想，指针本身是被按值传递的——如果你修改形参 x 的值——让它指向其他内存，肯定不会把实参 a 从内存的一个地方搬到另一个地方。*  
*而实参是被按指针传递的——modfiyValue() 函数得到了实参 a 的地址，就可以通过指针 x 肆意修改 a 的值，*   
*而 main() 函数只能眼睁睁看着 a 被修改，什么都做不了，:(*

按指针传递的应用场景有下面几个：

1. 按指针传递可以让函数修改不属于它的变量的值。例如`scanf()`函数就要求传入变量的地址（也是按指针传递），这样它才能用从标准输入取得的数据修改这些变量的值。反之，`printf()`函数不需要修改传入变量的值，就可以向标准输出输出数据，因此它采用按值传递。

2. 一个函数只能返回一个值，如果函数需要输出多个值，就可以利用按指针传递——向函数的参数列表中添加几个额外的指针，把那些不能返回的值放进去就好了。比如`<math.h>`中的`modf()`函数：
    ```C
    double modf(double x, double* integer)  //把 x 分解成整数部分和小数部分，返回小数部分，把 *integer 设置成整数部分
    ```

3. 如果需要传递的数据虽然不需要修改，但是其类型很复杂，占用大量的内存，那么按值传递就要 CPU 消耗大量的时间把数据从内存的一块复制到另一块——这显然不够经济。这时就可以利用按指针传递，向函数传入`const`指针，指针变量本身占用的内存很小，节约了复制数据的时间，而`const`关键字又可以防止意外修改重要数据。
    ```c
    struct student{
        int num;
        int score;
        int age;
        char str[100];
    };                  //复杂的数据类型占用很多内存
    typedef sturct student student
    void printStudentInfo(const student* stu) { //传入const指针，节约复制的时间，避免意外修改
        //do something
    }
    ```

总结一下：
- 按值传递适合传递简单的数据类型，不需要修改的数据。
- 按指针传递适合传递复杂的数据类型，需要修改的数据，还可以从函数接收多个输出值。但要注意，如果用指针传递不需要修改的，较复杂的数据结构，尽量使用`const`指针以避免意外的修改。

## 什么是 void* 指针？
`void*`是特殊的指针类型，它告诉程序，**不要对该指针指向的内存地址作出任何特殊的解释**。  
```C
void* malloc(size_t size) //malloc() 函数不知道你要把分配的内存作何用途，因此它返回一个 void* 指针，表示它不对这块内存中的数据做任何解释。
```
在执行类型转换之前，**不应该对`void*`指针做任何操作**，对`void*`指针做任何类型转换以外的操作（如自增，自减，解引用）都是没有意义的。
```C
int a = 1919810;
void* p = &a;
p++;                //无意义！编译错误，不允许这样做
printf("%c", *p);   //无意义！编译错误，不允许这样做
```
`void*`指针可以被编译器隐式转换为任何指针类型（转换是编译器自动进行的，且不会产生任何编译警告），反过来，其他任何指针也可以被编译器隐式转换为`void*`指针。这可能造成许多危险的问题，比如未定义行为（C 语言标准中没有明确规定结果的行为，可能产生无法确定的后果）。
```C
int a = 0721;       //其实这是个 8 进制数
int* p = &a;
void* q = p;        //隐式类型转换！没有触发任何编译警告
float* r = q;       //隐式类型转换！没有触发任何编译警告
printf("%f", *r);   //未定义行为！程序尝试把一个存放 int 数据的内存区域解释为一个 float 整数
```
因此，建议总是对`void*`指针执行强制类型转换。

`void*`指针常常被用于设计各种通用函数接口。例如我们熟悉的`qsort()`函数：
```C
void qsort(void* base, size_t num, size_t size, int (*compare)(const void* a, const void* b));
```
`qsort()`函数可以对任何数据类型的数组进行排序，这就利用了`void*`指针`base`可以传入任何数据类型的数据的特点。只要用`size`参数传递数组中每个元素的大小，用`compare()`函数规定比较方式即可。
```C
struct student{                                     //如果你还不知道什么是结构体，跳过这部分
    int age;
    char name[100];
};
typedef struct student student;
student a[100];
//input data
int comp(const void* a, const void* b) {            //为每个要排序的数据类型创建具体的 comp() 函数
    return ((student*)a)->age - ((student*)b)->age; 
}
qsort(&a, 100, sizeof(student), comp);
//qsort() 实际上并不清楚它在排序的是什么，它只知道每 sizeof(student) 个字节是一个单位数据，
//把两个数据传入 comp() 函数就可以得到这两个数据之间的大小关系，据此可以完成比较。
```

## 什么是函数指针？
函数指针也是一种指针。只不过它的数据类型告诉程序，**把这个指针指向的内存地址解释为一个函数**。
```C
int add(int a, int b) {
    return a + b;
}
int (*p)(int a, int b) = add;   //创建一个类型为 int(int, int) 的指针p
```
定义函数指针的方法很简单，只要写出一个正确的函数原型，随后把函数名用`(*<指针名>)`（注意括号，运算符的结合性导致这个括号是必须的）代替。
```C
//step 1
void processArray(int array[], int size);
//step 2
void (*ptr)(int array[], int size);
```
一个函数指针的类型包含了它指向的函数的返回值类型和形参列表。对于编译器而言，变量名，函数名等都没有任何意义（这些名字是给人类看的），因此，下面的代码都可以定义一个合法的函数指针：
```C
int (*p)(int a, int b); //编译器会自动忽略变量名 a 和 b
int (*q)(int, int);     //对编译器而言和上一条没什么区别，但是对人类更不友好
```
解引用函数指针即可得到其指向的函数本身。因此可以用函数指针调用函数。注意由于运算符的结合性，需要用括号包裹解引用运算符和指针名。
```C
int add(int a, int b) {
    return a + b;
}
int (*p)(int, int) = add;
printf("%d", (*p)(2, 3));   //解引用 p ,得到函数 add()，随后传入参数 2 和 3
```
运行结果：
```C
> 5
```
C 语言还提供了一种简化的写法，允许程序员把函数指针像函数名一样使用：
```C
int add(int a, int b) {
    return a + b;
}
int (*p)(int, int) = add;
printf("%d", p(2, 3));      // p(2, 3) 与 (*p)(2, 3) 没有任何区别
```
运行结果：
```C
> 5
```
函数指针最大的作用是允许一个函数被传递给另一个函数作为参数，从而提高函数的通用型。仍然以`qsort()`函数为例：
```C
void qsort(void* base, size_t num, size_t size, int (*compare)(const void* a, const void* b));
```
用户可以创建自己的比较函数，用函数指针传入`qsort()`，就可以让`qsort()`按照自己规定的规则比较数组里的元素，进而进行排序。

*如果一个函数以函数指针的形式作为参数被传递给其他函数，这个函数就称为**回调函数**。*
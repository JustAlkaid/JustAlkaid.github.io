# 100 行带你速通指针

## 什么是指针？
指针是存储**内存地址**的变量。指针变量的**值**叫做**指针指向的内存地址**。如果指针指向的内存地址属于某个变量，就说指针**指向这个变量**。
```C
int a = 114514;
int* p = &a;            //用取地址运算符 & 得到变量 a 的内存地址，随后把这个地址赋给 int* 型的指针变量 p
printf("%#010x", p);    //以十六进制输出 p 的值，用 0x 开头，包括 0x 在内至少 10 个字符
```
执行结果：
```C
> 0x00f3fe3c
```
（每次执行可能都会不同）

## 怎么定义指针？
在任何一个正常的数据类型后面加上`*`字符，就可以得到一个该数据类型衍生出的指针。
```C
int* p;                             //创建了一个 int* 型的指针
double* a;                          //创建了一个 double* 型的指针

struct student{                     //如果你还不知道什么是结构体，跳过这部分
    int age;
    char name[100];
};
typedef struct student student;
student* q;                         //创建了一个 struct student* 型的指针

int *a;                             //空格的位置无所谓。有人认为这种写法强调 *a 是一个 int 型变量，而正常写法强调 a 是一个 int* 型变量
int *a, *b;                         //创建了两个 int* 型指针 a 和 b
int* a, b;                          //创建了一个 int* 型指针 a 和一个 int 型变量 b，因此，声明指针时，每个指针前面都需要出现 * 字符
```

## 指针占据多大的内存空间？
依机器而定。市面上的电脑大多采用 64 位系统，此时指针变量占据 8 个字节的内存。如果你的电脑使用了 32 位系统或者在 64 位系统上安装了 32 位编译器，指针变量会占据 4 个字节的内存。  
*不难看出，4 个字节恰好是 32 位， 8 个字节恰好是 64 位。*

指针变量占据的内存与其类型无关。

```C
int *ptr = NULL;
printf("%zu", sizeof(ptr)); //使用 sizeof 运算符获取指针占用的内存空间的大小，以字节数表示
```

执行结果：
```C
> 4 （32 位系统/编译器）
> 8 （64 位系统和编译器）
```

*碎碎念：32 位系统下，一个指针占据 4 个字节，有 2^32 = 4,294,967,296 个可能的值，CPU 利用这样一个指针变量，最多能访问 4,294,967,296 个不同的字节。*  
*1KB = 1024byte， 1MB = 1024KB， 1GB = 1024MB，计算可得 32 位 CPU 可用的内存最多不超过 4GB，这远远不能满足不断发展的软件对内存的需求。*  
*随着芯片制造工艺的发展，超过 4GB 的大容量内存在市场上越来越常见，越来越廉价，32 位系统也就此退出了历史舞台。*

## 指针的类型表示什么？
指针变量的类型决定了它所指向的内存地址上存放的数据类型，换句话说，指针变量的类型告诉程序如何解释该内存地址上的数据。
```C
int* p = (int*)malloc(sizeof(int)); //分配一块大小为 int 变量大小的内存，赋值给 int* 型指针 p
//假定这部分代码运行在一个 int 变量为 4 个字节的机器上
//p 的类型是 int*，这告诉程序，要把 p 指向的字节和其后的 3 个字节存储的内容视为一个 int 型变量
```
粗略的说，如果你想知道一个指针的类型，那就从它的定义中把它的名字去掉，**保留所有其他的符号**。  
*（叹气）是的，这里有很多运算符优先级和结合性的问题。*
```C
int* p;                                                          //类型：int*
double** q;                                                      //类型：double**
char (*a)[20]                                                    //类型：char(*)[20]
int (*b)(int, int)                                               //类型：int (*)(int, int)
float (*c)(long long, short, void (*)(const void*, const void*)) //类型：float (*)(long long, short, void (*)(const void*, const void*))
```
*你得到了他们的类型，但这有什么用呢？这东西根本复杂到人不能理解。也许可以问问 AI？*

## 怎么使用指针？
对指针使用解引用运算符`*`，可以得到指针**指向的变量**的值。
```C
int a = 23333;
int* p = &a;        //指针存储了变量 a 的地址，或者说指针指向了变量 a
printf("%d", *p);   //输出指针指向的变量的值，即输出 a 的值。
```
执行结果：
```C
> 23333
```
对指针执行加法和减法，实质是指针指向的位置的移动，这被称为**指针算术**。  
指针算术受到指针变量类型的影响。每次对指针 +1，相当于把指针指向的位置向后移动一个“指针指向的数据类型”的大小。
```C
int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

int* p = a;                 //p 指向 a 的首地址，或者说 p 指向 a[0]
printf("%d\n", *p);         

printf("%d\n", *(p + 1));   /* p 是 int* 型指针，p + 1 表示 p 指向的位置向后移动一个 int 变量的大小，
                             * 因此 (p + 1) 指向 a[1]，注意这里的运算符优先级。
                             */

p = p + 2;                  //把 p 向后移动 2 个 int 变量的大小，指向 a[2]
printf("%d\n", *p);  

--p;                        //把 p 向前移动 1 个 int 变量的大小，指向 a[1]
printf("%d\n", *p); 

printf("%d\n", *p++);       /* 后置 ++ 的优先级高于解引用 *，因此 *p++ 被理解为*(p++)，
                             * 于是 * 运算符使用 p 自增前的值，为 printf 传入 1，
                             * 之后执行自增，p 向后移动 1 个 int 变量的大小，p指向 a[2]。
                             * 总之，如果你不知道运算符是怎么结合的，要么用括号，要么别乱压行。
                             */
printf("%d\n", *p); 
```
输出结果：
```C
> 0
> 1
> 2
> 1
> 1
> 2
```

## 多重指针是什么？

```C
```

## 顶层 const？底层 const？？

## 数组指针？还是指针数组？
数组指针是**指针**，指针数组是**数组**。  
更详细地说，数组指针是**指向数组的指针**，指针数组是**元素是指针的数组**。  
*（叹气）是的，这里也有很多运算符优先级和结合性的问题。*
```C
int (*a)[20];   //创建了一个类型为 int(*)[20] 的数组指针
int* b[20];     //创建了一个指针数组 b，它的每一个元素都是一个 int* 指针
```
与其他指针一样，数组指针的类型告诉程序该把它指向的内存地址解释为一个数组。
```C
int (*a)[20] = (int*[20])malloc(20 * sizeof(int));
```

## 什么是 void* 指针？
`void*`是特殊的指针类型，它告诉程序，**不要对该指针指向的内存地址作出任何特殊的解释**。  
```C
void* malloc(size_t size) //malloc() 函数不知道你要把分配的内存作何用途，因此它返回一个 void* 指针，表示它不对这块内存中的数据做任何解释。
```
在执行类型转换之前，**不应该对`void*`指针做任何操作**，对`void*`指针做任何类型转换以外的操作（如自增，自减，解引用）都是没有意义的。
```C
int a = 1919810;
void* p = &a;
p++;                //无意义！编译错误，不允许这样做
printf("%c", *p);   //无意义！编译错误，不允许这样做
```
`void*`指针可以被编译器隐式转换为任何指针类型（转换是编译器自动进行的，且不会产生任何编译警告），反过来，其他任何指针也可以被编译器隐式转换为`void*`指针。这可能造成许多危险的问题，比如未定义行为（C 语言标准中没有明确规定结果的行为，可能产生无法确定的后果）。
```C
int a = 0721;       //其实这是个 8 进制数
int* p = &a;
void* q = p;        //隐式类型转换！没有触发任何编译警告
float* r = q;       //隐式类型转换！没有触发任何编译警告
printf("%f", *r);   //未定义行为！程序尝试把一个存放 int 数据的内存区域解释为一个 float 整数
```
因此，建议总是对`void*`指针执行强制类型转换。

`void*`指针常常被用于设计各种通用函数接口。例如我们熟悉的`qsort()`函数：
```C
void qsort(void* base, size_t num, size_t size, int (*compare)(const void* a, const void* b));
```
`qsort()`函数可以对任何数据类型的数组进行排序，这就利用了`void*`指针`base`可以传入任何数据类型的数据的特点。只要用`size`参数传递数组中每个元素的大小，用`compare()`函数规定比较方式即可。
```C
struct student{                                     //如果你还不知道什么是结构体，跳过这部分
    int age;
    char name[100];
};
typedef struct student student;
student a[100];
//input data
int comp(const void* a, const void* b) {            //为每个要排序的数据类型创建具体的 comp() 函数
    return ((student*)a)->age - ((student*)b)->age; 
}
qsort(&a, 100, sizeof(student), comp);
//qsort() 实际上并不清楚它在排序的是什么，它只知道每 sizeof(student) 个字节是一个单位数据，
//把两个数据传入 comp() 函数就可以得到这两个数据之间的大小关系，据此可以完成比较。
```

## 什么是函数指针？
函数指针也是一种指针。只不过它的数据类型告诉程序，**把这个指针指向的内存地址解释为一个函数**。
```C
int add(int a, int b) {
    return a + b;
}
int (*p)(int a, int b) = add;   //创建一个类型为 int(int, int) 的指针p
```
定义函数指针的方法很简单，只要写出一个正确的函数原型，随后把函数名用`(*<指针名>)`（注意括号，运算符的结合性导致这个括号是必须的）代替。
```C
//step 1
void processArray(int array[], int size);
//step 2
void (*ptr)(int array[], int size);
```
一个函数指针的类型包含了它指向的函数的返回值类型和形参列表。对于编译器而言，变量名，函数名等都没有任何意义（这些名字是给人类看的），因此，下面的代码都可以定义一个合法的函数指针：
```C
int (*p)(int a, int b); //编译器会自动忽略变量名 a 和 b
int (*q)(int, int);     //对编译器而言和上一条没什么区别，但是对人类更不友好
```
解引用函数指针即可得到其指向的函数本身。因此可以用函数指针调用函数。注意由于运算符的结合性，需要用括号包裹解引用运算符和指针名。
```C
int add(int a, int b) {
    return a + b;
}
int (*p)(int, int) = add;
printf("%d", (*p)(2, 3));   //解引用 p ,得到函数 add()，随后传入参数 2 和 3
```
执行结果：
```C
> 5
```
C 语言还提供了一种简化的写法，允许程序员把函数指针像函数名一样使用：
```C
int add(int a, int b) {
    return a + b;
}
int (*p)(int, int) = add;
printf("%d", p(2, 3));      // p(2, 3) 与 (*p)(2, 3) 没有任何区别
```
执行结果：
```C
> 5
```
函数指针最大的作用是允许一个函数被传递给另一个函数作为参数，从而提高函数的通用型。仍然以`qsort()`函数为例：
```C
void qsort(void* base, size_t num, size_t size, int (*compare)(const void* a, const void* b));
```
用户可以创建自己的比较函数，用函数指针传入`qsort()`，就可以让`qsort()`按照自己规定的规则比较数组里的元素，进而进行排序。

*如果一个函数以函数指针的形式作为参数被传递给其他函数，这个函数就称为**回调函数**。*